import { cache } from 'react';
import { db } from '@/db';
import { sessionTable, usersTable } from '@/db/schema';
import { sha256 } from '@oslojs/crypto/sha2';
import { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from '@oslojs/encoding';
import { eq } from 'drizzle-orm';
import { cookies } from 'next/headers';

/**
 * Generates a secure session token.
 *
 * This function creates a 32-byte random value using the Web Crypto API,
 * encodes it in Base32 without padding, and returns the resulting string.
 *
 * @returns {string} A secure session token encoded in Base32 without padding.
 */
export function generateSessionToken(): string {
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);
  const token = encodeBase32LowerCaseNoPadding(bytes);
  return token;
}

const THIRTY_DAYS = 1000 * 60 * 60 * 24 * 30;
const FIFTEEN_DAYS = 1000 * 60 * 60 * 24 * 15;
/**
 * Creates a new session for a user.
 *
 * @param token - The token used to create the session ID.
 * @param userId - The ID of the user for whom the session is being created.
 * @returns A promise that resolves to the created session object.
 *
 * The session object contains the following properties:
 * - `id`: The session ID, generated by hashing the token.
 * - `user_id`: The ID of the user.
 * - `expires`: The expiration date of the session, set to 30 days from the current date.
 */
export async function createSession(token: string, userId: number) {
  const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
  // First verify the user exists
  const user = await db.select().from(usersTable).where(eq(usersTable.id, userId)).get();

  if (!user) {
    throw new Error(`User with ID ${userId} not found`);
  }

  const session = {
    id: sessionId,
    user_id: userId,
    expires: new Date(Date.now() + THIRTY_DAYS),
  };

  await db.insert(sessionTable).values(session);
  return session;
}

/**
 * Validates a session token and returns the associated session and user objects.
 *
 * @param token - The session token to validate
 * @returns A promise resolving to an object containing:
 *          - session: The session object if valid, null if invalid/expired
 *          - user: The associated user object if valid, null if invalid/expired
 *
 * This function:
 * - Validates the session exists and has not expired
 * - Updates session expiry if token is nearing expiration
 * - Returns both session and user details if valid
 * - Returns null values if session is invalid or expired
 */
export async function validateSessionToken(token: string) {
  const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
  const result = await db
    .select({
      user: usersTable,
      session: sessionTable,
    })
    .from(sessionTable)
    .innerJoin(usersTable, eq(sessionTable.user_id, usersTable.id))
    .where(eq(sessionTable.id, sessionId));

  if (result.length === 0) {
    return { session: null, user: null };
  }

  const { session, user } = result[0];

  if (Date.now() > session.expires.getTime()) {
    return { session: null, user: null };
  }

  if (Date.now() >= session.expires.getTime() - FIFTEEN_DAYS) {
    session.expires = new Date(Date.now() + THIRTY_DAYS);
    await db.update(sessionTable).set({ expires: session.expires }).where(eq(sessionTable.id, sessionId));
  }

  return { session, user };
}

/**
 * Invalidates a user session by deleting the session record from the database.
 *
 * @param sessionId - The unique identifier of the session to be invalidated.
 * @returns A promise that resolves when the session has been successfully deleted.
 */
export async function invalidateSession(sessionId: string) {
  await db.delete(sessionTable).where(eq(sessionTable.id, sessionId));
}

/* Session cookies should have the following attributes:

   HttpOnly: Cookies are only accessible server-side
   SameSite=Lax: Use Strict for critical websites
   Secure: Cookies can only be sent over HTTPS (Should be omitted when testing on localhost)
   Max-Age or Expires: Must be defined to persist cookies
   Path=/: Cookies can be accessed from all routes

   Lucia v3 used auth_session as the session cookie name. */

export async function setSessionCookie(token: string, expiresAt: Date): Promise<void> {
  const cookieStore = await cookies();
  cookieStore.set('auth_session', token, {
    httpOnly: true,
    sameSite: 'lax',
    secure: process.env.NODE_ENV === 'production',
    expires: expiresAt,
    path: '/',
  });
}

export async function clearSessionCookie(): Promise<void> {
  const cookieStore = await cookies();
  cookieStore.set('auth_session', '', {
    httpOnly: true,
    sameSite: 'lax',
    secure: process.env.NODE_ENV === 'production',
    maxAge: 0,
    path: '/',
  });
}

export const getCurrentSession = cache(async () => {
  const cookieStore = await cookies();
  const token = cookieStore.get('auth_session')?.value ?? null;
  if (token === null) {
    return { session: null, user: null };
  }
  const result = await validateSessionToken(token);
  return result;
});
