import { db } from '@/db';
import { sessionTable, usersTable } from '@/db/schema';
import { sha256 } from '@oslojs/crypto/sha2';
import { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from '@oslojs/encoding';
import { eq } from 'drizzle-orm';

/**
 * Generates a secure session token.
 *
 * This function creates a 32-byte random value using the Web Crypto API,
 * encodes it in Base32 without padding, and returns the resulting string.
 *
 * @returns {string} A secure session token encoded in Base32 without padding.
 */
export function generateSessionToken(): string {
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);
  const token = encodeBase32LowerCaseNoPadding(bytes);
  return token;
}

const THIRTY_DAYS = 1000 * 60 * 60 * 24 * 30;
const FIFTEEN_DAYS = 1000 * 60 * 60 * 24 * 15;
/**
 * Creates a new session for a user.
 *
 * @param token - The token used to create the session ID.
 * @param userId - The ID of the user for whom the session is being created.
 * @returns A promise that resolves to the created session object.
 *
 * The session object contains the following properties:
 * - `id`: The session ID, generated by hashing the token.
 * - `user_id`: The ID of the user.
 * - `expires`: The expiration date of the session, set to 30 days from the current date.
 */
export async function createSession(token: string, userId: number) {
  const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
  const session = {
    id: sessionId,
    user_id: userId,
    expires: new Date(Date.now() + THIRTY_DAYS),
  };

  await db.insert(sessionTable).values(session);
  return session;
}

/**
 * Validates a session token by checking its existence and expiration in the database.
 * If the session is close to expiring, it extends the expiration date.
 *
 * @param {string} token - The session token to validate.
 * @returns An object containing the session and user information.
 */
export async function validateSessionToken(token: string) {
  const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
  const result = await db
    .select({ user: usersTable, session: sessionTable })
    .from(sessionTable)
    .innerJoin(usersTable, eq(sessionTable.user_id, usersTable.id))
    .where(eq(sessionTable.id, sessionId));

  if (result.length === 0) {
    return { session: null, user: null };
  }

  const { session, user } = result[0];

  if (Date.now() > session.expires.getTime()) {
    return { session: null, user: null };
  }

  if (Date.now() >= session.expires.getTime() - FIFTEEN_DAYS) {
    session.expires = new Date(Date.now() + THIRTY_DAYS);
    await db.update(sessionTable).set({ expires: session.expires }).where(eq(sessionTable.id, sessionId));
  }

  return { session, user };
}

/**
 * Invalidates a user session by deleting the session record from the database.
 *
 * @param sessionId - The unique identifier of the session to be invalidated.
 * @returns A promise that resolves when the session has been successfully deleted.
 */
export async function invalidateSession(sessionId: string) {
  await db.delete(sessionTable).where(eq(sessionTable.id, sessionId));
}
